package encodingfuzz

// Edit if desired. Code generated by "fzgen ./pkg/encoding/".
// See https://github.com/thepudds/fzgen for more info

import (
	"bytes"
	"io"
	"testing"

	"github.com/felixge/traceutils/pkg/encoding"
	"github.com/stretchr/testify/require"
	"github.com/thepudds/fzgen/fuzzer"
)

func Fuzz_EncodeDecode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		// Create a decoder
		dec := encoding.NewDecoder(bytes.NewReader(data))

		// Create an encoder
		var outTrace bytes.Buffer
		enc := encoding.NewEncoder(&outTrace)

		// Decode and encode each event.
		for {
			beforeLen := outTrace.Len()
			e := encoding.Event{}
			if err := dec.Decode(&e); err != nil {
				require.Equal(t, io.EOF, err)
				break
			}
			require.NoError(t, enc.Encode(&e))

			// Check output after each event to understand errors without having to
			// diff the whole binary output.
			gotEncoded := outTrace.Bytes()[beforeLen:]
			wantEncoded := data[beforeLen : beforeLen+len(gotEncoded)]
			require.Equal(t, wantEncoded, gotEncoded, "failed to encode event: %v", e)
		}

		// Check that the length of the encoded trace is the same as the original.
		require.Equal(t, len(data), outTrace.Len())
		// Check that the encoded trace is the same as the original.
		require.Equal(t, data, outTrace.Bytes())
	})
}

func Fuzz_Decoder_Decode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		var e *encoding.Event
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &e)
		if e == nil {
			return
		}

		d := encoding.NewDecoder(r)
		d.Decode(e)
	})
}

func Fuzz_Encoder_Encode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w io.Writer
		var ev *encoding.Event
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ev)
		if ev == nil {
			return
		}

		e := encoding.NewEncoder(w)
		e.Encode(ev)
	})
}
